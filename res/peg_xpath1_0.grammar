/*
    An XPath 1.0 grammar derived from the XPath 1.0 Specification:
 
    http://www.w3.org/TR/xpath
    


    NOTE-TO-SELF: to avoid infinite recursion, I had to eliminate this production:
    
        abbreviatedRelativeLocationPath = relativeLocationPath '//' step;
    
    and therefore remove `abbreviatedRelativeLocationPath` from `relativeLocationPath` which changed from
        
        relativeLocationPath = step ('/' step)* | abbreviatedRelativeLocationPath;
        
    to:
    
        relativeLocationPath = step ('/' step)* ('//' step)?;
    
    
    AND functionName should be:

        functionName = qName - nodeType - booleanLiteral;
*/

@before {
        // TODO `$`

        PKTokenizer *t = self.tokenizer;
        [t.symbolState add:@"//"];
        [t.symbolState add:@".."];
        [t.symbolState add:@"!="];
        [t.symbolState add:@"::"];
        [t.symbolState add:@"<="];
        [t.symbolState add:@"=>"];
        [t.symbolState add:@"(:"];
        [t.symbolState add:@":)"];

        [t setTokenizerState:t.wordState from:'_' to:'_'];
        [t.wordState setWordChars:YES from:'-' to:'-'];
        [t.wordState setWordChars:YES from:'_' to:'_'];
        [t.wordState setWordChars:YES from:'.' to:'.'];
        [t.wordState setWordChars:NO from:'\\'' to:'\\''];

        [t setTokenizerState:t.numberState from:'.' to:'.'];

        [t setTokenizerState:t.numberState from:'#' to:'#'];
        t.numberState.allowsScientificNotation = YES;

        [t setTokenizerState:t.symbolState from:'/' to:'/'];

        [t.commentState addMultiLineStartMarker:@"(:" endMarker:@":)"];
        [t setTokenizerState:t.commentState from:'(' to:'('];
        [t setTokenizerState:t.commentState from:':' to:':'];
        [t.commentState setFallbackState:t.symbolState from:'(' to:'('];
        [t.commentState setFallbackState:t.symbolState from:':' to:':'];
}

@interface {
@property (nonatomic, assign) BOOL finderSupportEnabled;
}

stmt = expr;
expr = orExpr;
    orExpr = andExpr orAndExpr*;
        orAndExpr = (or andExpr);
        andExpr = equalityExpr andEqualityExpr*;
            andEqualityExpr = (and equalityExpr);

            equalityExpr = relationalExpr eqRelationalExpr*;
                eqRelationalExpr = ('=' | '!=') relationalExpr;

                relationalExpr = additiveExpr compareAdditiveExpr*;
                    compareAdditiveExpr = ('<' | '>' | '<=' | '>=') additiveExpr;
                    
                    additiveExpr = multiplicativeExpr plusOrMinusMultiExpr*;
                        plusOrMinusMultiExpr  = (('+' | '-') multiplicativeExpr);

                        multiplicativeExpr = unaryExpr multDivOrModUnaryExpr*;
                            multDivOrModUnaryExpr = ((multiplyOperator | div | mod) unaryExpr);
                            
                            multiplyOperator = '*';
                            unaryExpr = minusUnionExpr | unionExpr;
                                minusUnionExpr = '-'+ unionExpr;
                                unionExpr = pathExpr unionTail*;
                                unionTail = ('|' pathExpr);
    

pathExpr = filterPath | locationPath;
    filterPath = complexFilterPath | filterExpr;
    complexFilterPath = complexFilterPathStartExpr slashStep pathTail;
    complexFilterPathStartExpr = filterExpr;
    locationPath = relativeLocationPath | absoluteLocationPath;
        relativeLocationPath = firstRelativeStep pathTail;
        pathBody = step pathTail;
        pathTail = slashStep*;
        slashStep = (('/' | '//') step);
        absoluteLocationPath = rootSlash pathBody? | abbreviatedAbsoluteLocationPath;
            abbreviatedAbsoluteLocationPath = rootDoubleSlash pathBody;
            rootSlash = '/';
            rootDoubleSlash = '//';
            firstRelativeStep = step;

    filterExpr = primaryExpr predicate*;
        primaryExpr = variableReference | literal | number | functionCall | '('! expr ')'!;
            variableReference = '$' qName; // note whitespace is not allowed here. also qName is optional
            literal = QuotedString;
            number = Number;
            functionCall = actualFunctionCall | booleanLiteralFunctionCall;
                actualFunctionCall = functionName '(' (argument (','! argument)* )? ')';
                booleanLiteralFunctionCall = booleanLiteral '('! ')';
                    functionName = { NE(LS(1), @"true") && NE(LS(1), @"false") && NE(LS(1), @"comment") && NE(LS(1), @"text") && NE(LS(1), @"processing-instruction") && NE(LS(1), @"node") && (!_finderSupportEnabled || NE(LS(1), @"file") || NE(LS(1), @"folder") || NE(LS(1), @"image")) }? qName;
                    booleanLiteral = true | false;
                
                    qName = (prefix ':')? localPart;
                        prefix = ncName;
                        localPart = ncName;
                            ncName = Word | keyword;
                argument = expr;
        predicate = '['! predicateExpr ']';
            predicateExpr = expr;
                

    step = explicitAxisStep | abbreviatedStep | implicitAxisStep;
        explicitAxisStep = axis stepBody;
        implicitAxisStep = stepBody;
        
        axis = axisName '::'! | abbreviatedAxis;
            axisName = ancestor | ancestorOrSelf | attr | child | descendant | descendantOrSelf | following | followingSibling | namespace | parent | preceding | precedingSibling | self;
            abbreviatedAxis = '@';
        stepBody = nodeTest predicate*;
        nodeTest = typeTest | specificPITest | nameTest;
            nameTest = '*' ':' ncName | '*' | ncName ':' '*' | qName; // note whitespace should not be allowed in second alt here
            typeTest = nodeType '('! ')';
            nodeType = comment | text | processingInstruction | node | { _finderSupportEnabled }? folder | { _finderSupportEnabled }? file | { _finderSupportEnabled }? image;
            specificPITest = processingInstruction '('! literal ')';
        abbreviatedStep = '.' | '..';
            
ancestor = 'ancestor';
ancestorOrSelf = 'ancestor-or-self';
attr = 'attribute';
child = 'child';
descendant = 'descendant';
descendantOrSelf = 'descendant-or-self';
following = 'following';
followingSibling = 'following-sibling';
namespace = 'namespace';
parent = 'parent';
preceding = 'preceding';
precedingSibling = 'preceding-sibling';
self = 'self';
div = 'div';
mod = 'mod';
or = 'or';
and = 'and';
true = 'true';
false = 'false';
comment = 'comment';
text = 'text';
processingInstruction = 'processing-instruction';
node = 'node';
file = 'file';
folder = 'folder';
image = 'image';

keyword
    = ancestor
    | ancestorOrSelf 
    | attr
    | child 
    | descendant 
    | descendantOrSelf 
    | following 
    | followingSibling 
    | namespace 
    | parent 
    | preceding 
    | precedingSibling 
    | self 
    | div 
    | mod
    | or
    | and
    | true
    | false
    | comment
    | text
    | processingInstruction
    | node
    | file
    | folder
    | image
    ;
